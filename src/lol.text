import './style.css'
import { createOpenRouter } from '@openrouter/ai-sdk-provider'
import { streamText } from 'ai'
import removeMarkdown from 'remove-markdown'

const openrouter = createOpenRouter({
  apiKey: import.meta.env.VITE_OPENROUTER_KEY  
})

// ConfiguraciÃ³n de Eleven Labs VOZ
const ELEVENLABS_CONFIG = {
  apiKey: import.meta.env.VITE_ELEVENLABS_KEY,
  baseUrl: 'https://api.elevenlabs.io/v1',
  voices: {
    neutral: '21m00Tcm4TlvDq8ikWAM'  
  }
}

// Cache optimizado
const MESSAGE_CACHE = new Map()
const AUDIO_CACHE = new Map()

// Clase principal de Eleven Labs TTS
class ElevenLabsTTS {
  constructor(config) {
    this.config = config
    this.currentAudio = null
    this.audioQueue = []
    this.isPlaying = false
    
    if (!config.apiKey) {
      throw new Error('API Key de Eleven Labs es requerida')
    }
  }

  // ConfiguraciÃ³n neutral simplificada
  getNeutralSettings() {
    return {
      stability: 0.6,
      similarity_boost: 0.9,
      style: 0.1,
      use_speaker_boost: true
    }
  }

  // Generar audio con Eleven Labs
  async generateAudio(text) {
    const cacheKey = `${text}-neutral`
    if (AUDIO_CACHE.has(cacheKey)) {
      return AUDIO_CACHE.get(cacheKey)
    }

    try {
      const voiceId = this.config.voices.neutral
      const voiceSettings = this.getNeutralSettings()
      const response = await fetch(`${this.config.baseUrl}/text-to-speech/${voiceId}`, {
        method: 'POST',
        headers: {
          'Accept': 'audio/mpeg',
          'Content-Type': 'application/json',
          'xi-api-key': this.config.apiKey
        },
        body: JSON.stringify({
          text: text,
          model_id: 'eleven_multilingual_v2',
          voice_settings: voiceSettings
        })
      })

      if (!response.ok) {
        const errorText = await response.text()
        throw new Error(`Error ${response.status}: ${errorText}`)
      }

      const audioBlob = await response.blob()
      
      if (AUDIO_CACHE.size >= 25) {
        const firstKey = AUDIO_CACHE.keys().next().value
        AUDIO_CACHE.delete(firstKey)
      }
      AUDIO_CACHE.set(cacheKey, audioBlob)
      
      return audioBlob
    } catch (error) {
      console.error('Error generando audio:', error)
      throw error
    }
  }

  // Reproducir audio
  async playAudio(audioBlob) {
    return new Promise((resolve, reject) => {
      try {
        this.stopCurrent()
        const audioUrl = URL.createObjectURL(audioBlob)
        this.currentAudio = new Audio(audioUrl)
  
        this.currentAudio.onended = () => {
          URL.revokeObjectURL(audioUrl)
          this.currentAudio = null
          this.isPlaying = false
          resolve()
        }
        
        this.currentAudio.onerror = (error) => {
          URL.revokeObjectURL(audioUrl)
          this.currentAudio = null
          this.isPlaying = false
          reject(new Error('Error reproduciendo audio: ' + error.message))
        }
        
        this.isPlaying = true
        this.currentAudio.play()
      } catch (error) {
        this.isPlaying = false
        reject(error)
      }
    })
  }

  // FunciÃ³n principal para hablar
  async speak(text) {
    try {      
      const audioBlob = await this.generateAudio(text)
      await this.playAudio(audioBlob)
      console.log('âœ… ReproducciÃ³n completada exitosamente')
    } catch (error) {
      console.error('âŒ Error en speak:', error)
      throw error
    }
  }

  stopCurrent() {
    if (this.currentAudio) {
      this.currentAudio.pause()
      this.currentAudio.currentTime = 0
      this.currentAudio = null
    }
    this.isPlaying = false
  }

  // Sistema de cola para mÃºltiples mensajes
  async addToQueue(text) {
    this.audioQueue.push({ text })
    
    if (!this.isPlaying) {
      await this.processQueue()
    }
  }

  async processQueue() {
    while (this.audioQueue.length > 0) {
      const { text } = this.audioQueue.shift()
      try {
        await this.speak(text)
      } catch (error) {
        console.error('Error procesando cola:', error)
        break
      }
    }
  }

  // Limpiar cache
  clearCache() {
    AUDIO_CACHE.clear()
  }

  // Obtener informaciÃ³n del cache
  getCacheInfo() {
    return {
      audioCache: AUDIO_CACHE.size,
      messageCache: MESSAGE_CACHE.size
    }
  }
}

// FunciÃ³n para limpiar texto de markdown
function cleanMarkdownText(text) {
  return removeMarkdown(text, {
    stripListLeaders: true,
    listUnicodeChar: '',
    gfm: true,
    useImgAltText: false
  });
}

// FunciÃ³n optimizada para limpiar texto completo
const cleanText = (() => {
  const patterns = [
    /```[\s\S]*?```/g,        // Bloques de cÃ³digo
    /https?:\/\/[^\s]+/gi,    // URLs
    /\b\d+\.\d+\b/g,          // NÃºmeros decimales
    /[^\w\s\.,;:!?Â¿Â¡Ã¡Ã©Ã­Ã³ÃºÃ±Ã¼ÃÃ‰ÃÃ“ÃšÃ‘Ãœ]/gi, // Caracteres especiales
    /\s+/g,                   // Espacios mÃºltiples
    /\n\s*\n/g               // LÃ­neas vacÃ­as mÃºltiples
  ]
  
  const replacements = [
    '',
    'enlace',
    (match) => match.replace('.', ' punto '),
    '',
    ' ',
    '\n'
  ]
  
  return (text) => {
    let cleaned = cleanMarkdownText(text)
    
    patterns.forEach((pattern, i) => {
      if (typeof replacements[i] === 'function') {
        cleaned = cleaned.replace(pattern, replacements[i])
      } else {
        cleaned = cleaned.replace(pattern, replacements[i])
      }
    })
    
    return cleaned.trim()
  }
})()

// Instancia global del TTS
let ttsEngine = null

// Inicializar el motor TTS
function initializeTTS() {
  try {
    ttsEngine = new ElevenLabsTTS(ELEVENLABS_CONFIG)
    return true
  } catch (error) {
    console.error('âŒ Error inicializando Eleven Labs:', error)
    return false
  }
}

// FunciÃ³n principal de texto a voz
async function speakText(text) {
  if (!text || text.trim().length === 0) {
    console.warn('âš ï¸ Texto vacÃ­o, omitiendo TTS')
    return
  }
  
  if (!ttsEngine) {
    throw new Error('TTS Engine no estÃ¡ inicializado. Verifica tu API Key de Eleven Labs.')
  }

  const cleanedText = cleanText(text)
  
  try {
    await ttsEngine.speak(cleanedText)
  } catch (error) {
    console.error('âŒ Error en speakText:', error)
    throw error
  }
}

// FunciÃ³n para detener
function stopSpeaking() {
  if (ttsEngine) {
    ttsEngine.stopCurrent()
  }
  console.log('ðŸ”‡ ReproducciÃ³n detenida')
}

// Mensajes del sistema simplificados
const WELCOME_MESSAGES = [
  "Â¡Hola! Soy tu asistente EndyOS. Â¡Estoy emocionado de ayudarte hoy!",
  "Â¡Bienvenido! Me alegra verte por aquÃ­. Â¿En quÃ© puedo ayudarte?",
  "Hola, soy EndyOS, tu asistente inteligente. Estoy aquÃ­ para lo que necesites.",
  "Â¡Saludos! Soy tu asistente virtual EndyOS. Â¿QuÃ© aventura de conocimiento tendremos hoy?"
]

const THINKING_MESSAGES = [
  "Hmm, interesante pregunta. DÃ©jame procesar esto...",
  "Â¡QuÃ© consulta tan fascinante! Dame un momento para analizarla...",
  "Â¡Me encanta este tipo de preguntas! Trabajando en la respuesta...",
  "Analizando todos los aspectos de tu consulta..."
]

const ERROR_MESSAGES = [
  "Lo siento, ha ocurrido un error tÃ©cnico. Por favor, intÃ©ntalo de nuevo.",
  "Parece que hay un problema. Dame un momento para solucionarlo."
]

const getRandomMessage = (messageArray) => 
  messageArray[Math.floor(Math.random() * messageArray.length)]

// InicializaciÃ³n del sistema
window.addEventListener('load', () => {
  setTimeout(async () => {
    const initialized = initializeTTS()
    
    if (initialized) {
      const welcomeMsg = getRandomMessage(WELCOME_MESSAGES)
      try {
        await speakText(welcomeMsg)
      } catch (error) {
        console.error('Error en mensaje de bienvenida:', error)
      }
    } else {
      console.error('âŒ No se pudo inicializar el sistema TTS')
    }
  }, 1200)
})

// Manejo del formulario
const form = document.querySelector('#form')
const promptInput = document.querySelector('#prompt')

let isProcessing = false

form?.addEventListener('submit', async (e) => {
  e.preventDefault()
  
  if (isProcessing) return
  
  const prompt = promptInput.value.trim()
  if (!prompt) {
    await speakText("Por favor, escribe algo para que pueda ayudarte.")
    return
  }
  
  isProcessing = true
  
  try {
    // Verificar cache de mensajes
    const cacheKey = prompt.toLowerCase()
    if (MESSAGE_CACHE.has(cacheKey)) {
      const cachedResponse = MESSAGE_CACHE.get(cacheKey)
      await speakText(cachedResponse)
      return
    }
    
    // Mensaje de procesamiento
    const thinkingMsg = getRandomMessage(THINKING_MESSAGES)
    await speakText(thinkingMsg)
    
    // Obtener respuesta de OpenRouter
    const response = streamText({
      model: openrouter('deepseek/deepseek-chat-v3.1:free'),
      prompt: `Responde de manera conversacional y natural: ${prompt}`
    })
    
    let fullText = ''
    
    for await (const chunk of response.textStream) {
      fullText += chunk
    }
    
    if (fullText.trim()) {
      const cleanedResponse = cleanText(fullText)
      
      // Guardar en cache (mÃ¡ximo 50 entradas)
      if (MESSAGE_CACHE.size >= 50) {
        const firstKey = MESSAGE_CACHE.keys().next().value
        MESSAGE_CACHE.delete(firstKey)
      }
      MESSAGE_CACHE.set(cacheKey, cleanedResponse)
      
      await speakText(cleanedResponse)
    }
    
  } catch (error) {
    console.error('Error en el flujo principal:', error)
    const errorMsg = getRandomMessage(ERROR_MESSAGES)
    await speakText(errorMsg)
  } finally {
    isProcessing = false
    promptInput.value = ''
  }
})

// Soporte para Enter sin Shift
promptInput?.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault()
    form?.dispatchEvent(new Event('submit'))
  }
})

// Funciones de utilidad adicionales
function getTTSStatus() {
  if (!ttsEngine) return 'No inicializado'
  return {
    isPlaying: ttsEngine.isPlaying,
    cacheInfo: ttsEngine.getCacheInfo(),
    configuredVoices: Object.keys(ELEVENLABS_CONFIG.voices).length
  }
}

function clearAllCaches() {
  MESSAGE_CACHE.clear()
  if (ttsEngine) {
    ttsEngine.clearCache()
  }
}

export { 
  speakText, 
  stopSpeaking, 
  cleanMarkdownText,
  getTTSStatus,
  clearAllCaches
}