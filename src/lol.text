import './style.css'
import { createOpenRouter } from '@openrouter/ai-sdk-provider'
import { streamText } from 'ai'
import removeMarkdown from 'remove-markdown'

const openrouter = createOpenRouter({
  apiKey: import.meta.env.VITE_OPENROUTER_KEY  
})

// Configuración de Eleven Labs VOZ
const ELEVENLABS_CONFIG = {
  apiKey: import.meta.env.VITE_ELEVENLABS_KEY,
  baseUrl: 'https://api.elevenlabs.io/v1',
  voices: {
    neutral: '21m00Tcm4TlvDq8ikWAM'  
  }
}

// Cache optimizado
const MESSAGE_CACHE = new Map()
const AUDIO_CACHE = new Map()

// Clase principal de Eleven Labs TTS
class ElevenLabsTTS {
  constructor(config) {
    this.config = config
    this.currentAudio = null
    this.audioQueue = []
    this.isPlaying = false
    
    if (!config.apiKey) {
      throw new Error('API Key de Eleven Labs es requerida')
    }
  }

  // Configuración neutral simplificada
  getNeutralSettings() {
    return {
      stability: 0.6,
      similarity_boost: 0.9,
      style: 0.1,
      use_speaker_boost: true
    }
  }

  // Generar audio con Eleven Labs
  async generateAudio(text) {
    const cacheKey = `${text}-neutral`
    if (AUDIO_CACHE.has(cacheKey)) {
      return AUDIO_CACHE.get(cacheKey)
    }

    try {
      const voiceId = this.config.voices.neutral
      const voiceSettings = this.getNeutralSettings()
      const response = await fetch(`${this.config.baseUrl}/text-to-speech/${voiceId}`, {
        method: 'POST',
        headers: {
          'Accept': 'audio/mpeg',
          'Content-Type': 'application/json',
          'xi-api-key': this.config.apiKey
        },
        body: JSON.stringify({
          text: text,
          model_id: 'eleven_multilingual_v2',
          voice_settings: voiceSettings
        })
      })

      if (!response.ok) {
        const errorText = await response.text()
        throw new Error(`Error ${response.status}: ${errorText}`)
      }

      const audioBlob = await response.blob()
      
      if (AUDIO_CACHE.size >= 25) {
        const firstKey = AUDIO_CACHE.keys().next().value
        AUDIO_CACHE.delete(firstKey)
      }
      AUDIO_CACHE.set(cacheKey, audioBlob)
      
      return audioBlob
    } catch (error) {
      console.error('Error generando audio:', error)
      throw error
    }
  }

  // Reproducir audio
  async playAudio(audioBlob) {
    return new Promise((resolve, reject) => {
      try {
        this.stopCurrent()
        const audioUrl = URL.createObjectURL(audioBlob)
        this.currentAudio = new Audio(audioUrl)
  
        this.currentAudio.onended = () => {
          URL.revokeObjectURL(audioUrl)
          this.currentAudio = null
          this.isPlaying = false
          resolve()
        }
        
        this.currentAudio.onerror = (error) => {
          URL.revokeObjectURL(audioUrl)
          this.currentAudio = null
          this.isPlaying = false
          reject(new Error('Error reproduciendo audio: ' + error.message))
        }
        
        this.isPlaying = true
        this.currentAudio.play()
      } catch (error) {
        this.isPlaying = false
        reject(error)
      }
    })
  }

  // Función principal para hablar
  async speak(text) {
    try {      
      const audioBlob = await this.generateAudio(text)
      await this.playAudio(audioBlob)
      console.log('✅ Reproducción completada exitosamente')
    } catch (error) {
      console.error('❌ Error en speak:', error)
      throw error
    }
  }

  stopCurrent() {
    if (this.currentAudio) {
      this.currentAudio.pause()
      this.currentAudio.currentTime = 0
      this.currentAudio = null
    }
    this.isPlaying = false
  }

  // Sistema de cola para múltiples mensajes
  async addToQueue(text) {
    this.audioQueue.push({ text })
    
    if (!this.isPlaying) {
      await this.processQueue()
    }
  }

  async processQueue() {
    while (this.audioQueue.length > 0) {
      const { text } = this.audioQueue.shift()
      try {
        await this.speak(text)
      } catch (error) {
        console.error('Error procesando cola:', error)
        break
      }
    }
  }

  // Limpiar cache
  clearCache() {
    AUDIO_CACHE.clear()
  }

  // Obtener información del cache
  getCacheInfo() {
    return {
      audioCache: AUDIO_CACHE.size,
      messageCache: MESSAGE_CACHE.size
    }
  }
}

// Función para limpiar texto de markdown
function cleanMarkdownText(text) {
  return removeMarkdown(text, {
    stripListLeaders: true,
    listUnicodeChar: '',
    gfm: true,
    useImgAltText: false
  });
}

// Función optimizada para limpiar texto completo
const cleanText = (() => {
  const patterns = [
    /```[\s\S]*?```/g,        // Bloques de código
    /https?:\/\/[^\s]+/gi,    // URLs
    /\b\d+\.\d+\b/g,          // Números decimales
    /[^\w\s\.,;:!?¿¡áéíóúñüÁÉÍÓÚÑÜ]/gi, // Caracteres especiales
    /\s+/g,                   // Espacios múltiples
    /\n\s*\n/g               // Líneas vacías múltiples
  ]
  
  const replacements = [
    '',
    'enlace',
    (match) => match.replace('.', ' punto '),
    '',
    ' ',
    '\n'
  ]
  
  return (text) => {
    let cleaned = cleanMarkdownText(text)
    
    patterns.forEach((pattern, i) => {
      if (typeof replacements[i] === 'function') {
        cleaned = cleaned.replace(pattern, replacements[i])
      } else {
        cleaned = cleaned.replace(pattern, replacements[i])
      }
    })
    
    return cleaned.trim()
  }
})()

// Instancia global del TTS
let ttsEngine = null

// Inicializar el motor TTS
function initializeTTS() {
  try {
    ttsEngine = new ElevenLabsTTS(ELEVENLABS_CONFIG)
    return true
  } catch (error) {
    console.error('❌ Error inicializando Eleven Labs:', error)
    return false
  }
}

// Función principal de texto a voz
async function speakText(text) {
  if (!text || text.trim().length === 0) {
    console.warn('⚠️ Texto vacío, omitiendo TTS')
    return
  }
  
  if (!ttsEngine) {
    throw new Error('TTS Engine no está inicializado. Verifica tu API Key de Eleven Labs.')
  }

  const cleanedText = cleanText(text)
  
  try {
    await ttsEngine.speak(cleanedText)
  } catch (error) {
    console.error('❌ Error en speakText:', error)
    throw error
  }
}

// Función para detener
function stopSpeaking() {
  if (ttsEngine) {
    ttsEngine.stopCurrent()
  }
  console.log('🔇 Reproducción detenida')
}

// Mensajes del sistema simplificados
const WELCOME_MESSAGES = [
  "¡Hola! Soy tu asistente EndyOS. ¡Estoy emocionado de ayudarte hoy!",
  "¡Bienvenido! Me alegra verte por aquí. ¿En qué puedo ayudarte?",
  "Hola, soy EndyOS, tu asistente inteligente. Estoy aquí para lo que necesites.",
  "¡Saludos! Soy tu asistente virtual EndyOS. ¿Qué aventura de conocimiento tendremos hoy?"
]

const THINKING_MESSAGES = [
  "Hmm, interesante pregunta. Déjame procesar esto...",
  "¡Qué consulta tan fascinante! Dame un momento para analizarla...",
  "¡Me encanta este tipo de preguntas! Trabajando en la respuesta...",
  "Analizando todos los aspectos de tu consulta..."
]

const ERROR_MESSAGES = [
  "Lo siento, ha ocurrido un error técnico. Por favor, inténtalo de nuevo.",
  "Parece que hay un problema. Dame un momento para solucionarlo."
]

const getRandomMessage = (messageArray) => 
  messageArray[Math.floor(Math.random() * messageArray.length)]

// Inicialización del sistema
window.addEventListener('load', () => {
  setTimeout(async () => {
    const initialized = initializeTTS()
    
    if (initialized) {
      const welcomeMsg = getRandomMessage(WELCOME_MESSAGES)
      try {
        await speakText(welcomeMsg)
      } catch (error) {
        console.error('Error en mensaje de bienvenida:', error)
      }
    } else {
      console.error('❌ No se pudo inicializar el sistema TTS')
    }
  }, 1200)
})

// Manejo del formulario
const form = document.querySelector('#form')
const promptInput = document.querySelector('#prompt')

let isProcessing = false

form?.addEventListener('submit', async (e) => {
  e.preventDefault()
  
  if (isProcessing) return
  
  const prompt = promptInput.value.trim()
  if (!prompt) {
    await speakText("Por favor, escribe algo para que pueda ayudarte.")
    return
  }
  
  isProcessing = true
  
  try {
    // Verificar cache de mensajes
    const cacheKey = prompt.toLowerCase()
    if (MESSAGE_CACHE.has(cacheKey)) {
      const cachedResponse = MESSAGE_CACHE.get(cacheKey)
      await speakText(cachedResponse)
      return
    }
    
    // Mensaje de procesamiento
    const thinkingMsg = getRandomMessage(THINKING_MESSAGES)
    await speakText(thinkingMsg)
    
    // Obtener respuesta de OpenRouter
    const response = streamText({
      model: openrouter('deepseek/deepseek-chat-v3.1:free'),
      prompt: `Responde de manera conversacional y natural: ${prompt}`
    })
    
    let fullText = ''
    
    for await (const chunk of response.textStream) {
      fullText += chunk
    }
    
    if (fullText.trim()) {
      const cleanedResponse = cleanText(fullText)
      
      // Guardar en cache (máximo 50 entradas)
      if (MESSAGE_CACHE.size >= 50) {
        const firstKey = MESSAGE_CACHE.keys().next().value
        MESSAGE_CACHE.delete(firstKey)
      }
      MESSAGE_CACHE.set(cacheKey, cleanedResponse)
      
      await speakText(cleanedResponse)
    }
    
  } catch (error) {
    console.error('Error en el flujo principal:', error)
    const errorMsg = getRandomMessage(ERROR_MESSAGES)
    await speakText(errorMsg)
  } finally {
    isProcessing = false
    promptInput.value = ''
  }
})

// Soporte para Enter sin Shift
promptInput?.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault()
    form?.dispatchEvent(new Event('submit'))
  }
})

// Funciones de utilidad adicionales
function getTTSStatus() {
  if (!ttsEngine) return 'No inicializado'
  return {
    isPlaying: ttsEngine.isPlaying,
    cacheInfo: ttsEngine.getCacheInfo(),
    configuredVoices: Object.keys(ELEVENLABS_CONFIG.voices).length
  }
}

function clearAllCaches() {
  MESSAGE_CACHE.clear()
  if (ttsEngine) {
    ttsEngine.clearCache()
  }
}

export { 
  speakText, 
  stopSpeaking, 
  cleanMarkdownText,
  getTTSStatus,
  clearAllCaches
}